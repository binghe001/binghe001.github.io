(window.webpackJsonp=window.webpackJsonp||[]).push([[829],{1128:function(t,e,r){"use strict";r.r(e);var n=r(7),a=Object(n.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"《seckill秒杀系统》第110章-实现基于token编排机制防刷"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#《seckill秒杀系统》第110章-实现基于token编排机制防刷"}},[t._v("#")]),t._v(" 《Seckill秒杀系统》第110章：实现基于Token编排机制防刷")]),t._v(" "),e("p",[t._v("作者：冰河\n"),e("br"),t._v("星球："),e("a",{attrs:{href:"http://m6z.cn/6aeFbs",target:"_blank",rel:"noopener noreferrer"}},[t._v("http://m6z.cn/6aeFbs"),e("OutboundLink")],1),t._v(" "),e("br"),t._v("博客："),e("a",{attrs:{href:"https://binghe.gitcode.host",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://binghe.gitcode.host"),e("OutboundLink")],1),t._v(" "),e("br"),t._v("文章汇总："),e("a",{attrs:{href:"https://binghe.gitcode.host/md/all/all.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://binghe.gitcode.host/md/all/all.html"),e("OutboundLink")],1),t._v(" "),e("br"),t._v("源码获取地址："),e("a",{attrs:{href:"https://t.zsxq.com/0dhvFs5oR",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://t.zsxq.com/0dhvFs5oR"),e("OutboundLink")],1)]),t._v(" "),e("blockquote",[e("p",[t._v("沉淀，成长，突破，帮助他人，成就自我。")])]),t._v(" "),e("ul",[e("li",[t._v("本章难度：★★☆☆☆")]),t._v(" "),e("li",[t._v("本章重点：实现秒杀系统基于Token编排机制的防刷方案，掌握秒杀系统基于Token编排机制的防刷原理，并能够将基于Token编排机制防刷的落地方案和实现方式灵活应用到自身实际项目中。")])]),t._v(" "),e("p",[e("strong",[t._v("大家好，我是冰河~~")])]),t._v(" "),e("p",[t._v("基于限流的方式来防刷，在实现上比较简单粗暴，并且也是最直接的一种实现方式，能够有效的解决针对单个接口的刷单流量问题，但是如果想要在业务流程上对这些刷单流量进行限制，也就是说，需要访问秒杀系统接口的流量按照既定的接口顺序进行访问，不得绕过某些步骤，此时，就需要引入流程编排的Token机制。")]),t._v(" "),e("h2",{attrs:{id:"一、前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、前言"}},[t._v("#")]),t._v(" 一、前言")]),t._v(" "),e("p",[t._v("在前面实现的基于限流防刷，虽然能够解决针对单个接口的刷单流量问题，但是不能解决跳步刷单问题。也就是说，基于限流的防刷方案不能解决按照业务流程顺序调用接口的问题。此时，我们就需要引入基于Token编排机制的防刷策略。")]),t._v(" "),e("p",[t._v("大部分小伙伴应该对Token并不陌生，Token一般都是用来做鉴权的。在秒杀场景下，我们其实可以基于Token实现接口的编排：如果调用的接口有先后顺序，在调用下一个接口之前，要先在上一个接口获得Token令牌，带上Token令牌后才能调用下一个接口，不然就会认为是非法请求。通过这种Token编排机制，不仅可以防止大量刷单的问题，还能预防多端操作对数据的篡改问题。")]),t._v(" "),e("h2",{attrs:{id:"二、本章诉求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、本章诉求"}},[t._v("#")]),t._v(" 二、本章诉求")]),t._v(" "),e("p",[t._v("在流量网关层实现基于Token编排机制的防刷功能，掌握基于Token编排机制的防刷原理与实现流程，并能够将基于Token编排机制的防刷落地方案灵活应用到自身实际项目中。")]),t._v(" "),e("h2",{attrs:{id:"三、token编排的交互流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、token编排的交互流程"}},[t._v("#")]),t._v(" 三、Token编排的交互流程")]),t._v(" "),e("p",[t._v("在秒杀系统中，我们会为获取秒杀活动列表、获取秒杀活动详情、获取秒杀商品列表、获取秒杀商品详情和抢购下单五个接口加上Token的生成和校验规则，当用户访问这些接口时，必须按照获取秒杀活动列表—>获取秒杀活动详情—>获取秒杀商品列表—>获取秒杀商品详情—>抢购下单的顺序进行访问。")]),t._v(" "),e("p",[t._v("为了让大家更加直观的了解Token编排的交互流程，这里，我简单画了一张时序图，如图110-1所示。")]),t._v(" "),e("div",{attrs:{align:"center"}},[e("img",{attrs:{src:"https://binghe.gitcode.host/images/project/seckill/seckill-2023-09-20-001.png?raw=true",width:"80%"}}),t._v(" "),e("br")]),t._v(" "),e("p",[t._v("可以看到，访问下一个接口时，会在header中带上上一个接口的header里返回的x-st-token，下一个接口会对x-st-token进行校验，如果校验成功，则执行后续业务逻辑，并返回结果。如果校验失败，则直接返回错误信息。")]),t._v(" "),e("p",[t._v("注意：这里每一个接口的header里返回的x-st-token都不同，下一个接口对上一个接口返回的x-st-token进行严格校验，如果校验失败，直接返回错误信息，只有校验成功，才会执行接口业务逻辑，以此达到接口编排的效果。")]),t._v(" "),e("h2",{attrs:{id:"四、实现token防刷"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四、实现token防刷"}},[t._v("#")]),t._v(" 四、实现Token防刷")]),t._v(" "),e("h2",{attrs:{id:"查看完整文章"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#查看完整文章"}},[t._v("#")]),t._v(" 查看完整文章")]),t._v(" "),e("p",[t._v("加入"),e("a",{attrs:{href:"http://m6z.cn/6aeFbs",target:"_blank",rel:"noopener noreferrer"}},[t._v("冰河技术"),e("OutboundLink")],1),t._v("知识星球，解锁完整技术文章与完整代码")])])}),[],!1,null,null,null);e.default=a.exports}}]);