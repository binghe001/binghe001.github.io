(window.webpackJsonp=window.webpackJsonp||[]).push([[331],{630:function(_,t,r){"use strict";r.r(t);var a=r(7),e=Object(a.a)({},(function(){var _=this,t=_._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"《spring核心技术》第31章-深度解析spring事务隔离级别与传播机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#《spring核心技术》第31章-深度解析spring事务隔离级别与传播机制"}},[_._v("#")]),_._v(" 《Spring核心技术》第31章：深度解析Spring事务隔离级别与传播机制")]),_._v(" "),t("p",[_._v("作者：冰河\n"),t("br"),_._v("星球："),t("a",{attrs:{href:"http://m6z.cn/6aeFbs",target:"_blank",rel:"noopener noreferrer"}},[_._v("http://m6z.cn/6aeFbs"),t("OutboundLink")],1),_._v(" "),t("br"),_._v("博客："),t("a",{attrs:{href:"https://binghe.gitcode.host",target:"_blank",rel:"noopener noreferrer"}},[_._v("https://binghe.gitcode.host"),t("OutboundLink")],1),_._v(" "),t("br"),_._v("文章汇总："),t("a",{attrs:{href:"https://binghe.gitcode.host/md/all/all.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("https://binghe.gitcode.host/md/all/all.html"),t("OutboundLink")],1),_._v(" "),t("br"),_._v("源码地址："),t("a",{attrs:{href:"https://github.com/binghe001/spring-annotation-book/tree/master/spring-annotation-chapter-29",target:"_blank",rel:"noopener noreferrer"}},[_._v("https://github.com/binghe001/spring-annotation-book/tree/master/spring-annotation-chapter-29"),t("OutboundLink")],1)]),_._v(" "),t("blockquote",[t("p",[_._v("沉淀，成长，突破，帮助他人，成就自我。")])]),_._v(" "),t("p",[t("strong",[_._v("大家好，我是冰河~~")])]),_._v(" "),t("hr"),_._v(" "),t("ul",[t("li",[t("p",[t("strong",[_._v("本章难度")]),_._v("：★★★★☆")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("本章重点")]),_._v("：进一步学习并掌握Spring事务的隔离级别与传播机制，从源码角度彻底理解Spring事务的隔离级别与传播机制。")])])]),_._v(" "),t("hr"),_._v(" "),t("p",[_._v("本章目录如下所示：")]),_._v(" "),t("ul",[t("li",[_._v("学习指引")]),_._v(" "),t("li",[_._v("事务隔离级别\n"),t("ul",[t("li",[_._v("ISOLATION_DEFAULT隔离级别")]),_._v(" "),t("li",[_._v("ISOLATION_READ_UNCOMMITTED隔离级别")]),_._v(" "),t("li",[_._v("ISOLATION_READ_COMMITTED隔离级别")]),_._v(" "),t("li",[_._v("ISOLATION_REPEATABLE_READ隔离级别")]),_._v(" "),t("li",[_._v("ISOLATION_SERIALIZABLE隔离级别")])])]),_._v(" "),t("li",[_._v("事务传播机制\n"),t("ul",[t("li",[_._v("七种事务传播机制类型")]),_._v(" "),t("li",[_._v("REQUIRED事务传播类型")]),_._v(" "),t("li",[_._v("REQUIRES_NEW事务传播类型")]),_._v(" "),t("li",[_._v("SUPPORTS事务传播类型")]),_._v(" "),t("li",[_._v("MANDATORY事务传播类型")]),_._v(" "),t("li",[_._v("NOT_SUPPORTED事务传播类型")]),_._v(" "),t("li",[_._v("NEVER事务传播类型")]),_._v(" "),t("li",[_._v("NESTED事务传播类型")]),_._v(" "),t("li",[_._v("常用的事务传播类型")])])]),_._v(" "),t("li",[_._v("总结")]),_._v(" "),t("li",[_._v("思考")]),_._v(" "),t("li",[_._v("VIP服务")])]),_._v(" "),t("h2",{attrs:{id:"一、学习指引"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、学习指引"}},[_._v("#")]),_._v(" 一、学习指引")]),_._v(" "),t("p",[t("code",[_._v("你了解过Spring事务的隔离级别和传播机制吗？")])]),_._v(" "),t("p",[_._v("关于Spring事务，有两个非常重要的知识点，那就是Spring事务的隔离级别和事务传播机制，本章，就系统介绍下Spring中的事务隔离级别和事务传播机制。")]),_._v(" "),t("h2",{attrs:{id:"二、事务隔离级别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、事务隔离级别"}},[_._v("#")]),_._v(" 二、事务隔离级别")]),_._v(" "),t("p",[t("code",[_._v("相信学习过Spring事务的小伙伴都应该了解过Spring的事务隔离级别吧？")])]),_._v(" "),t("p",[_._v("在Spring中，存在着五种隔离级别，分别为ISOLATION_DEFAULT、ISOLATION_READ_UNCOMMITTED、ISOLATION_READ_COMMITTED、ISOLATION_REPEATABLE_READ、ISOLATION_SERIALIZABLE。")]),_._v(" "),t("p",[_._v("接下来，就简单介绍下这些Spring的事务隔离级别。")]),_._v(" "),t("h3",{attrs:{id:"_2-1-isolation-default隔离级别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-isolation-default隔离级别"}},[_._v("#")]),_._v(" 2.1 ISOLATION_DEFAULT隔离级别")]),_._v(" "),t("p",[_._v("ISOLATION_DEFAULT隔离级别是Spring中PlatformTransactionManager默认的事务隔离级别，如果将Spring的事务隔离级别设置为ISOLATION_DEFAULT，则会使用数据库默认的事务隔离级别。")]),_._v(" "),t("p",[_._v("也就是说，将Spring的事务隔离级别设置为ISOLATION_DEFAULT时，Spring不做事务隔离级别的处理，会直接使用数据库默认的事务隔离级别。")]),_._v(" "),t("h3",{attrs:{id:"_2-2-isolation-read-uncommitted隔离级别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-isolation-read-uncommitted隔离级别"}},[_._v("#")]),_._v(" 2.2 ISOLATION_READ_UNCOMMITTED隔离级别")]),_._v(" "),t("p",[_._v("ISOLATION_READ_UNCOMMITTED隔离级别是Spring中最低级别的隔离级别。当Spring中的隔离级别设置为ISOLATION_READ_UNCOMMITTED时，一个事务A能够读取到另一个事务B未提交的数据。这种隔离级别下会产生脏读、不可重复读和幻读的问题。相当于MySQL中的READ UNCOMMITTED隔离级别。")]),_._v(" "),t("h3",{attrs:{id:"_2-3-isolation-read-committed隔离级别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-isolation-read-committed隔离级别"}},[_._v("#")]),_._v(" 2.3 ISOLATION_READ_COMMITTED隔离级别")]),_._v(" "),t("p",[_._v("ISOLATION_READ_COMMITTED隔离级别能够保证一个事务A修改的数据提交之后才能被另一个事务B读取，另一个事务B不能读取事务A未提交的事务。在这种隔离级别下，解决了脏读问题，但是可能会出现不可重复读和幻读的问题。相当于MySQL中的READ COMMITTED隔离级别。")]),_._v(" "),t("h3",{attrs:{id:"_2-4-isolation-repeatable-read隔离级别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-isolation-repeatable-read隔离级别"}},[_._v("#")]),_._v(" 2.4 ISOLATION_REPEATABLE_READ隔离级别")]),_._v(" "),t("p",[_._v("ISOLATION_REPEATABLE_READ隔离级别能够保证不会出现脏读和不可重复读的问题，但是可能会出现幻读的问题。如果一个事务A第一次按照一定的查询条件从数据表中查询出数据后，另一个事务B向同一个数据表中插入了符合事务A的查询条件的数据，事务A再次从数据表中查询数据时，会将事务B新插入的数据查询出来。相当于MySQL中的REPEATABLE READ隔离级别。")]),_._v(" "),t("h3",{attrs:{id:"_2-5-isolation-serializable隔离级别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-isolation-serializable隔离级别"}},[_._v("#")]),_._v(" 2.5 ISOLATION_SERIALIZABLE隔离级别")]),_._v(" "),t("p",[_._v("ISOLATION_SERIALIZABLE隔离级别下，事务只能够按照特定的顺序执行，也就是多个事务之间只能够按照串行化的顺序执行。这是一种最可靠的隔离级别，但是这种可靠性付出了极大的代价，那就是牺牲了并发性。相当于MySQL中的SERIALIZABLE隔离级别。")]),_._v(" "),t("h2",{attrs:{id:"查看完整文章"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查看完整文章"}},[_._v("#")]),_._v(" 查看完整文章")]),_._v(" "),t("p",[_._v("加入"),t("a",{attrs:{href:"http://m6z.cn/6aeFbs",target:"_blank",rel:"noopener noreferrer"}},[_._v("冰河技术"),t("OutboundLink")],1),_._v("知识星球，解锁完整技术文章与完整代码")])])}),[],!1,null,null,null);t.default=e.exports}}]);