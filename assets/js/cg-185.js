(window.webpackJsonp=window.webpackJsonp||[]).push([[185],{520:function(e,t,a){"use strict";a.r(t);var r=a(15),v=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"《jvm核心技术》第11章-jvm各种参数配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#《jvm核心技术》第11章-jvm各种参数配置"}},[e._v("#")]),e._v(" 《JVM核心技术》第11章：JVM各种参数配置")]),e._v(" "),t("p",[t("strong",[e._v("大家好，我是冰河~~")])]),e._v(" "),t("p",[e._v("今天跟大家聊聊JVM中的各种参数配置，好了不多说了，开始今天的正题。")]),e._v(" "),t("h2",{attrs:{id:"参数打印相关设置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参数打印相关设置"}},[e._v("#")]),e._v(" 参数打印相关设置")]),e._v(" "),t("p",[e._v("-XX:+PrintCommandLineFlags 可以在程序运行前打印出用户手动设置或是JVM自动设置的XX参数。")]),e._v(" "),t("p",[e._v("-XX:+PrintFlagsInitial 打印出所有XX参数的默认值。")]),e._v(" "),t("p",[e._v("-XX:+PrintFlagsFinal 打印出XX参数在运行程序时生效的值。")]),e._v(" "),t("p",[e._v("-XX:+PrintVMOptions 打印JVM的参数。")]),e._v(" "),t("h2",{attrs:{id:"堆、栈、方法区等内存大小设置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆、栈、方法区等内存大小设置"}},[e._v("#")]),e._v(" 堆、栈、方法区等内存大小设置")]),e._v(" "),t("h3",{attrs:{id:"栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[e._v("#")]),e._v(" 栈")]),e._v(" "),t("p",[e._v("-Xss1m 设置每个线程栈大小为1m，等价于-XX:ThreadStackSize=1m。")]),e._v(" "),t("h3",{attrs:{id:"堆"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[e._v("#")]),e._v(" 堆")]),e._v(" "),t("p",[e._v("-Xms2048m 设置JVM初始堆内存为2048m，等价于-XX:InitialHeapSize。")]),e._v(" "),t("p",[e._v("-Xmx2048 设置JVM最大堆内存为2018m，等价于-XX:MaxHeapSize。")]),e._v(" "),t("p",[e._v("-Xmn1g 设置年轻代大小为1g，官方推荐配置为整个堆大小的3/8。")]),e._v(" "),t("p",[e._v("-XX:NewSize=1024m 设置年轻代初始值为1024m。")]),e._v(" "),t("p",[e._v("-XXMaxNewSize=1024m 设置年轻代最大值为1024m。")]),e._v(" "),t("blockquote",[t("p",[e._v("3、4、5的关系官方文档描述是 The -XX:NewSize option is equivalent to -Xmn.\nInstead of the -Xmn option to set both the initial and maximum size of the heap for the young generation, you can use -XX:NewSize to set the initial size and -XX:MaxNewSize to set the maximum size.")])]),e._v(" "),t("p",[e._v("-XX:SurvivorRatio=8 设置年轻代中Eden区和一个survivor区的比值，默认为8。")]),e._v(" "),t("p",[e._v("-XX:+UseAdaptiveSizePolicy 开启自动选择各区大小比例")]),e._v(" "),t("blockquote",[t("p",[e._v("UseAdaptiveSizePolicy默认是开启的，此时SurvivorRatio=8是不生效的，将UseAdaptiveSizePolicy关闭后，设置SurvivorRatio=8才会生效，Eden:survivor=8:1")])]),e._v(" "),t("p",[e._v("-XX:NewRatio=2 设置老年代和年轻代（包括1个Eden和2个Survivor）的比值，默认为2，表示年轻代占整个堆空间的1/3，老年代占2/3。")]),e._v(" "),t("p",[e._v("-XX:PretenureSizeThreshold=1024 大于此阀值的对象直接分配在老年代，默认值的单位是字节，自行设置时也可以写成1m，只对Serial、ParNew收集器有效。")]),e._v(" "),t("p",[e._v("-XX:MaxTenuringThreshold=15 默认值是15，年轻代每次MinorGC后，还存活的对象年龄+1，当对象的年龄大于设置的这个值时就进入老年代。")]),e._v(" "),t("p",[e._v("-XX:-PrintTenuringDistribution，让JVM在每次MinorGC后打印出当前使用的Survivor中对象的年龄分布，默认是关闭的。")]),e._v(" "),t("p",[e._v("-XX:TargetSurvivorRatio 表示MinorGC结束后Survivor中占用空间的期望比例。")]),e._v(" "),t("h2",{attrs:{id:"方法区"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法区"}},[e._v("#")]),e._v(" 方法区")]),e._v(" "),t("h3",{attrs:{id:"before-jdk8"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#before-jdk8"}},[e._v("#")]),e._v(" Before JDK8")]),e._v(" "),t("p",[e._v("-XX:PermSize=128m 设置永久代初始值为128m。")]),e._v(" "),t("p",[e._v("-XX:MaxPermSize=128m 设置永久代最大值为128m。")]),e._v(" "),t("h3",{attrs:{id:"jdk8"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jdk8"}},[e._v("#")]),e._v(" JDK8")]),e._v(" "),t("p",[e._v("-XX:MetaspaceSize 设置元空间初始大小，默认是21807104个字节，约为21m。")]),e._v(" "),t("p",[e._v("-XX:MaxMetaspaceSize 设置元空间最大值，默认无限制。")]),e._v(" "),t("p",[e._v("-XX:+UseCompressedOops 开启压缩对象指针，默认开启。")]),e._v(" "),t("p",[e._v("-XX:+UseCompressedClassPointers 开启压缩类指针，默认开启。")]),e._v(" "),t("p",[e._v("-XX:CompressedClassSpaceSize 设置Klass Metaspace大小，默认1g。")]),e._v(" "),t("h2",{attrs:{id:"直接内存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#直接内存"}},[e._v("#")]),e._v(" 直接内存")]),e._v(" "),t("p",[e._v("1.-XX:MaxDirectMemorySize 指定直接内存容量，默认值是0。")]),e._v(" "),t("blockquote",[t("p",[e._v("官方文档描述\nSets the maximum total size (in bytes) of the New I/O (the java.nio package) direct-buffer allocations. Append the letter k or K to indicate kilobytes, m or M to indicate megabytes, g or G to indicate gigabytes. By default, the size is set to 0, meaning that the JVM chooses the size for NIO direct-buffer allocations automatically.")])]),e._v(" "),t("h2",{attrs:{id:"oom相关设置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#oom相关设置"}},[e._v("#")]),e._v(" OOM相关设置")]),e._v(" "),t("p",[e._v("-XX:+HeapDumpOnOutOfMemoryError 开启后，在出现OOM时生成dump文件。")]),e._v(" "),t("p",[e._v("-XX:+HeapDumpBeforeFullGC 开启后，在出现FullGC前生成dump文件。")]),e._v(" "),t("p",[e._v("-XX:HeapDumpPath=</path/aa.hprof> 指定dump文件存储路径。")]),e._v(" "),t("p",[e._v("-XX:OnOutOfMemoryError 当发生OOM时，执行指定脚本。eg: -XX:OnOutOfMemoryError=/opt/Server/restart.sh")]),e._v(" "),t("h2",{attrs:{id:"垃圾收集器相关设置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集器相关设置"}},[e._v("#")]),e._v(" 垃圾收集器相关设置")]),e._v(" "),t("h3",{attrs:{id:"serial收集器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#serial收集器"}},[e._v("#")]),e._v(" Serial收集器")]),e._v(" "),t("p",[e._v("-XX:+UseSerialGC 指定年轻代和老年代都是用串行收集器。对应年轻代使用Serial GC，老年代使用Serial Old GC。")]),e._v(" "),t("h3",{attrs:{id:"parnew收集器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parnew收集器"}},[e._v("#")]),e._v(" ParNew收集器")]),e._v(" "),t("p",[e._v("1.-XX:+UseParNewGC 指定年轻代使用ParNew并行收集器，不影响老年代。")]),e._v(" "),t("p",[e._v("2.-XX:ParallelGCThreads 限制1中并行线程数量，默认开启和CPU数量相同的线程数。")]),e._v(" "),t("h3",{attrs:{id:"parallel收集器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parallel收集器"}},[e._v("#")]),e._v(" Parallel收集器")]),e._v(" "),t("p",[e._v("-XX:+UseParallelGC 开启年轻代使用Parallel并行收集器执行内存回收任务。")]),e._v(" "),t("p",[e._v("-XX:+UseParallelOldGC 开启老年代使用并行回收器。")]),e._v(" "),t("blockquote",[t("p",[e._v("Parallel在JDK8中默认开启，1和2配套使用，开启其中一个参数，另一个也会被开启。")])]),e._v(" "),t("p",[e._v("-XX:ParallelGCThreads 设置年轻代并行收集器的线程数。一般和CPU数量相等，以避免过多的线程数影响垃圾收集性能。")]),e._v(" "),t("blockquote",[t("p",[e._v("在默认情况下，当CPU数量小于等于8个，ParallelGCThreads的值等于CPU数量。\n当CUP数量大于8个，ParallelGCThreads的值等于 3 + 5 * CPU_COUNT / 8。")])]),e._v(" "),t("p",[e._v("-XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间（STW），单位是毫秒。")]),e._v(" "),t("p",[e._v("-XX:GCTimeRatio 垃圾收集时间占总时间的比例 1 / (N + 1)，取值范围(0, 100)，默认值99，也就是垃圾回收时间不超过1%。")]),e._v(" "),t("p",[e._v("-XX:+UseAdaptiveSizePolicy 设置PS（Parallel Scavenge）收集器开启自适应调节策略。")]),e._v(" "),t("blockquote",[t("p",[e._v("此种模式下，年轻代的大小、Eden和Survivor的比例，晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间的平衡点。使用此种模式仅需设置虚拟机最大堆，目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMillis）。")])]),e._v(" "),t("h3",{attrs:{id:"cms收集器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cms收集器"}},[e._v("#")]),e._v(" CMS收集器")]),e._v(" "),t("p",[e._v("-XX:+UseConcMarkSweepGC 开启使用CMS收集器进行垃圾回收。")]),e._v(" "),t("blockquote",[t("p",[e._v("开启该参数会自动将-XX:+UseParNewGC开启，即：年轻代（ParNew）+ 老年代（CMS）+ Serial Old 组合。")])]),e._v(" "),t("p",[e._v("-XX:CMSLnitiatingOccupanyFraction 设置堆内存使用率阀值，到达该阀值便开始回收。")]),e._v(" "),t("p",[e._v("-XX:+UseCMSCompactAtFullCollection 默认开启，在进行Full GC时开启内存碎的合并整理过程，此过程无法并发，会导致停顿时间变长。")]),e._v(" "),t("p",[e._v("-XX:CMSFullGCsBeforeCompaction 此参数的作用是CMS收集器在执行过若干次不整理空间的FullGC之后，下一次进入FullGC前会先进行碎片整理，默认值为0，表示每次进入Full GC时都进行碎片整理。")]),e._v(" "),t("h3",{attrs:{id:"g1收集器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#g1收集器"}},[e._v("#")]),e._v(" G1收集器")]),e._v(" "),t("p",[e._v("官方文档：https://docs.oracle.com/en/java/javase/13/docs/specs/man/java.html")]),e._v(" "),t("p",[e._v("-XX:+UseG1GC 开启G1收集器。")]),e._v(" "),t("p",[e._v("-XX:G1HeapRegionSize 设置每个Region的大小，值是2的N次幂，范围1m ~ 32m，目标是根据最小的Java堆划分出月2048个区域。")]),e._v(" "),t("p",[e._v("-XX:MaxGCPauseMillis 设置期望到达的最大GC停顿时间，默认值是200ms。")]),e._v(" "),t("p",[e._v("-XX:ParallelGCThreads 设置STW时GC线程数，最大值为8。")]),e._v(" "),t("p",[e._v("-XX:ConcGCThreads 设置并发标记的线程数，参考值：ParallelGCThreads 的1/4左右。")]),e._v(" "),t("p",[e._v("-XX:InitiatingHeapOccupancyPercent 设置触发并发GC的堆占用率阀值，默认值为45%。")]),e._v(" "),t("p",[e._v("-XX:G1NewSizePercent -XX:G1MaxNewSizePercent 设置新生代占用整堆内存的最小百分比（默认5%）、最大百分比（默认60%）。")]),e._v(" "),t("p",[e._v("-XX:G1ReservePercent 保留内存区域，防止survivor中的to区溢出，默认值10%。")]),e._v(" "),t("h2",{attrs:{id:"gc日志相关设置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gc日志相关设置"}},[e._v("#")]),e._v(" GC日志相关设置")]),e._v(" "),t("p",[e._v("-verbose:gc 输出简化gc日志信息。")]),e._v(" "),t("p",[e._v("-XX:+PrintGC 等价于 -verbose:gc。")]),e._v(" "),t("p",[e._v("-XX:+PrintGCDetails 在发生垃圾回收是打印内存回收详细的日志，并在进程退出时输出当前内存各区域的使用情况。")]),e._v(" "),t("p",[e._v("-XX:+PrintGCTimeStamps 输出GC发生时的时间戳，要配合 -XX:+PrintGCDetails 一起使用。")]),e._v(" "),t("p",[e._v("-XX:+PrintGCDateStamps 输出GC发生时的时间戳（以日期的形式展示），要配合 -XX:+PrintGCDetails 一起使用。")]),e._v(" "),t("p",[e._v("-XX:+PrintHeapAtGC 每一次GC前、GC后都打印堆信息。")]),e._v(" "),t("p",[e._v("-Xloggc:"),t("file",[e._v(" 把GC日志写到文件中。")])],1),e._v(" "),t("h2",{attrs:{id:"写在最后"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#写在最后"}},[e._v("#")]),e._v(" 写在最后")]),e._v(" "),t("p",[e._v("在冰河的知识星球有大量从零开始带你手写的企业级生产项目，像DeepSeek大模型、手写高性能熔断组件、手写通用指标上报组件、手写高性能数据库路由组件、分布式IM即时通讯系统、Sekill分布式秒杀系统、手写RPC、简易商城系统等等，这些项目的需求、方案、架构、落地等均来自互联网真实业务场景，让你真正学到互联网大厂的业务与技术落地方案，并将其有效转化为自己的知识储备。")]),e._v(" "),t("p",[t("strong",[e._v("值得一提的是：冰河自研的Polaris高性能网关比某些开源网关项目性能更高，并且冰河也正在为企业级高性能RPC框架录制视频，全程带你分析原理和手撸代码。")]),e._v(" 你还在等啥？不少小伙伴经过星球硬核技术和项目的历练，早已成功跳槽加薪，实现薪资翻倍，而你，还在原地踏步，抱怨大环境不好。抛弃焦虑和抱怨，我们一起塌下心来沉淀硬核技术和项目，让自己的薪资更上一层楼。")]),e._v(" "),t("div",{attrs:{align:"center"}},[t("img",{attrs:{src:"https://binghe.gitcode.host/images/personal/xingqiu_149.png?raw=true",width:"80%"}}),e._v(" "),t("br")]),e._v(" "),t("p",[e._v("目前，领券加入星球就可以跟冰河一起学习《DeepSeek大模型》、《手写高性能通用熔断组件项目》、《手写高性能通用监控指标上报组件》、《手写高性能数据库路由组件项目》、《手写简易商城脚手架项目》、《手写高性能RPC项目》和《Spring6核心技术与源码解析》、《实战高并发设计模式》、《分布式Seckill秒杀系统》、《分布式IM即时通讯系统》和《手写高性能Polaris网关》，从零开始介绍原理、设计架构、手撸代码。")]),e._v(" "),t("p",[t("strong",[e._v("花很少的钱就能学这么多硬核技术、中间件项目和大厂秒杀系统与分布式IM即时通讯系统，比其他培训机构不知便宜多少倍，硬核多少倍，如果是我，我会买他个十年！")])]),e._v(" "),t("p",[e._v("加入要趁早，后续还会随着项目和加入的人数涨价，而且只会涨，不会降，先加入的小伙伴就是赚到。")]),e._v(" "),t("p",[e._v("另外，还有一个限时福利，邀请一个小伙伴加入，冰河就会给一笔 "),t("strong",[e._v("分享有奖")]),e._v(" ，有些小伙伴都邀请了50+人，早就回本了！")]),e._v(" "),t("h2",{attrs:{id:"其他方式加入星球"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#其他方式加入星球"}},[e._v("#")]),e._v(" 其他方式加入星球")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("链接")]),e._v(" ：打开链接 http://m6z.cn/6aeFbs 加入星球。")]),e._v(" "),t("li",[t("strong",[e._v("回复")]),e._v(" ：在公众号 "),t("strong",[e._v("冰河技术")]),e._v(" 回复 "),t("strong",[e._v("星球")]),e._v(" 领取优惠券加入星球。")])]),e._v(" "),t("p",[t("strong",[e._v("特别提醒：")]),e._v(" 苹果用户进圈或续费，请加微信 "),t("strong",[e._v("hacker_binghe")]),e._v(" 扫二维码，或者去公众号 "),t("strong",[e._v("冰河技术")]),e._v(" 回复 "),t("strong",[e._v("星球")]),e._v(" 扫二维码加入星球。")]),e._v(" "),t("h2",{attrs:{id:"联系冰河"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#联系冰河"}},[e._v("#")]),e._v(" 联系冰河")]),e._v(" "),t("h3",{attrs:{id:"加群交流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#加群交流"}},[e._v("#")]),e._v(" 加群交流")]),e._v(" "),t("p",[e._v("本群的宗旨是给大家提供一个良好的技术学习交流平台，所以杜绝一切广告！由于微信群人满 100 之后无法加入，请扫描下方二维码先添加作者 “冰河” 微信(hacker_binghe)，备注："),t("code",[e._v("星球编号")]),e._v("。")]),e._v(" "),t("div",{attrs:{align:"center"}},[t("img",{attrs:{src:"https://binghe.gitcode.host/images/personal/hacker_binghe.jpg?raw=true",width:"180px"}}),e._v(" "),t("div",{staticStyle:{"font-size":"18px"}},[e._v("冰河微信")]),e._v(" "),t("br")]),e._v(" "),t("h3",{attrs:{id:"公众号"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#公众号"}},[e._v("#")]),e._v(" 公众号")]),e._v(" "),t("p",[e._v("分享各种编程语言、开发技术、分布式与微服务架构、分布式数据库、分布式事务、云原生、大数据与云计算技术和渗透技术。另外，还会分享各种面试题和面试技巧。内容在 "),t("strong",[e._v("冰河技术")]),e._v(" 微信公众号首发，强烈建议大家关注。")]),e._v(" "),t("div",{attrs:{align:"center"}},[t("img",{attrs:{src:"https://binghe.gitcode.host/images/personal/ice_wechat.jpg?raw=true",width:"180px"}}),e._v(" "),t("div",{staticStyle:{"font-size":"18px"}},[e._v("公众号：冰河技术")]),e._v(" "),t("br")]),e._v(" "),t("h3",{attrs:{id:"视频号"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#视频号"}},[e._v("#")]),e._v(" 视频号")]),e._v(" "),t("p",[e._v("定期分享各种编程语言、开发技术、分布式与微服务架构、分布式数据库、分布式事务、云原生、大数据与云计算技术和渗透技术。另外，还会分享各种面试题和面试技巧。")]),e._v(" "),t("div",{attrs:{align:"center"}},[t("img",{attrs:{src:"https://binghe.gitcode.host/images/personal/ice_video.png?raw=true",width:"180px"}}),e._v(" "),t("div",{staticStyle:{"font-size":"18px"}},[e._v("视频号：冰河技术")]),e._v(" "),t("br")]),e._v(" "),t("h3",{attrs:{id:"星球"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#星球"}},[e._v("#")]),e._v(" 星球")]),e._v(" "),t("p",[e._v("加入星球 "),t("strong",[t("a",{attrs:{href:"http://m6z.cn/6aeFbs",target:"_blank",rel:"noopener noreferrer"}},[e._v("冰河技术"),t("OutboundLink")],1)]),e._v("，可以获得本站点所有学习内容的指导与帮助。如果你遇到不能独立解决的问题，也可以添加冰河的微信："),t("strong",[e._v("hacker_binghe")]),e._v("， 我们一起沟通交流。另外，在星球中不只能学到实用的硬核技术，还能学习"),t("strong",[e._v("实战项目")]),e._v("！")]),e._v(" "),t("p",[e._v("关注 "),t("a",{attrs:{href:"https://img-blog.csdnimg.cn/20210426115714643.jpg?raw=true",target:"_blank",rel:"noopener noreferrer"}},[e._v("冰河技术"),t("OutboundLink")],1),e._v("公众号，回复 "),t("code",[e._v("星球")]),e._v(" 可以获取入场优惠券。")]),e._v(" "),t("div",{attrs:{align:"center"}},[t("img",{attrs:{src:"https://binghe.gitcode.host/images/personal/xingqiu.png?raw=true",width:"180px"}}),e._v(" "),t("div",{staticStyle:{"font-size":"18px"}},[e._v("知识星球：冰河技术")]),e._v(" "),t("br")]),e._v(" "),t("p",[t("strong",[e._v("好了，今天就到这儿吧，我是冰河，我们下期见~~")])])])}),[],!1,null,null,null);t.default=v.exports}}]);