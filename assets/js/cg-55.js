(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{348:function(a,t,s){"use strict";s.r(t);var r=s(7),v=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"关于java8的stream-api-都在这儿了"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关于java8的stream-api-都在这儿了"}},[a._v("#")]),a._v(" 关于Java8的Stream API,都在这儿了")]),a._v(" "),t("h2",{attrs:{id:"写在前面"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#写在前面"}},[a._v("#")]),a._v(" 写在前面")]),a._v(" "),t("blockquote",[t("p",[a._v("Java8中有两大最为重要的改变。第一个是 Lambda 表达式；另外一个则是 Stream API(java.util.stream.*)  ，那什么是Stream API呢？Java8中的Stream又该如何使用呢？")])]),a._v(" "),t("h2",{attrs:{id:"什么是stream"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是stream"}},[a._v("#")]),a._v(" 什么是Stream?")]),a._v(" "),t("p",[a._v("Java8中有两大最为重要的改变。第一个是 Lambda 表达式；另外一个则是 Stream API(java.util.stream.*)。")]),a._v(" "),t("p",[a._v("Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式")]),a._v(" "),t("blockquote",[t("p",[a._v("流是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。“集合讲的是数据，流讲的是计算！ ”")])]),a._v(" "),t("p",[t("strong",[a._v("注意：")]),a._v("\n① Stream 自己不会存储元素。\n② Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。\n③ Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。")]),a._v(" "),t("h2",{attrs:{id:"stream操作的三个步骤"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#stream操作的三个步骤"}},[a._v("#")]),a._v(" Stream操作的三个步骤")]),a._v(" "),t("ul",[t("li",[a._v("创建 Stream")])]),a._v(" "),t("p",[a._v("一个数据源（如： 集合、数组）， 获取一个流。")]),a._v(" "),t("ul",[t("li",[a._v("中间操作")])]),a._v(" "),t("p",[a._v("一个中间操作链，对数据源的数据进行处理。")]),a._v(" "),t("ul",[t("li",[a._v("终止操作(终端操作)")])]),a._v(" "),t("p",[a._v("一个终止操作，执行中间操作链，并产生结果 。")]),a._v(" "),t("p",[t("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://binghe001.github.io/images/java/java8/2022-03-31-008-001.jpg",loading:"lazy"}})]),a._v(" "),t("h2",{attrs:{id:"如何创建stream"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何创建stream"}},[a._v("#")]),a._v(" 如何创建Stream?")]),a._v(" "),t("p",[a._v("Java8 中的 Collection 接口被扩展，提供了两个获取流的方法：")]),a._v(" "),t("h3",{attrs:{id:"_1-获取stream"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-获取stream"}},[a._v("#")]),a._v(" 1.获取Stream")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("default Stream"),t("E",[a._v(" stream() : 返回一个顺序流")])],1)]),a._v(" "),t("li",[t("p",[a._v("default Stream"),t("E",[a._v(" parallelStream() : 返回一个并行流")])],1)])]),a._v(" "),t("h3",{attrs:{id:"_2-由数组创建stream"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-由数组创建stream"}},[a._v("#")]),a._v(" 2.由数组创建Stream")]),a._v(" "),t("p",[a._v("Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：")]),a._v(" "),t("ul",[t("li",[a._v("static "),t("T",[a._v(" Stream"),t("T",[a._v(" stream(T[] array): 返回一个流")])],1)],1)]),a._v(" "),t("p",[a._v("重载形式，能够处理对应基本类型的数组：")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("public static IntStream stream(int[] array)")])]),a._v(" "),t("li",[t("p",[a._v("public static LongStream stream(long[] array)")])]),a._v(" "),t("li",[t("p",[a._v("public static DoubleStream stream(double[] array)")])])]),a._v(" "),t("h3",{attrs:{id:"_3-由值创建流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-由值创建流"}},[a._v("#")]),a._v(" 3.由值创建流")]),a._v(" "),t("p",[a._v("可以使用静态方法 Stream.of(), 通过显示值创建一个流。它可以接收任意数量的参数。")]),a._v(" "),t("ul",[t("li",[a._v("public static"),t("T",[a._v(" Stream"),t("T",[a._v(" of(T... values) : 返回一个流")])],1)],1)]),a._v(" "),t("h3",{attrs:{id:"_4-由函数创建流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-由函数创建流"}},[a._v("#")]),a._v(" 4.由函数创建流")]),a._v(" "),t("p",[a._v("由函数创建流可以创建无限流。")]),a._v(" "),t("p",[a._v("可以使用静态方法 Stream.iterate() 和Stream.generate(), 创建无限流 。")]),a._v(" "),t("ul",[t("li",[a._v("迭代")])]),a._v(" "),t("p",[a._v("public static"),t("T",[a._v(" Stream"),t("T",[a._v(" iterate(final T seed, final UnaryOperator"),t("T",[a._v(" f)")])],1)],1)],1),a._v(" "),t("ul",[t("li",[a._v("生成")])]),a._v(" "),t("p",[a._v("public static"),t("T",[a._v(" Stream"),t("T",[a._v(" generate(Supplier"),t("T",[a._v(" s)")])],1)],1)],1),a._v(" "),t("h2",{attrs:{id:"stream的中间操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#stream的中间操作"}},[a._v("#")]),a._v(" Stream的中间操作")]),a._v(" "),t("p",[a._v("多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”")]),a._v(" "),t("h3",{attrs:{id:"_1-筛选与切片"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-筛选与切片"}},[a._v("#")]),a._v(" 1.筛选与切片")]),a._v(" "),t("p",[t("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://binghe001.github.io/images/java/java8/2022-03-31-008-002.jpg",loading:"lazy"}})]),a._v(" "),t("h3",{attrs:{id:"_2-映射"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-映射"}},[a._v("#")]),a._v(" 2.映射")]),a._v(" "),t("p",[t("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://binghe001.github.io/images/java/java8/2022-03-31-008-003.jpg",loading:"lazy"}})]),a._v(" "),t("h3",{attrs:{id:"_3-排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-排序"}},[a._v("#")]),a._v(" 3.排序")]),a._v(" "),t("p",[t("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://binghe001.github.io/images/java/java8/2022-03-31-008-004.jpg",loading:"lazy"}})]),a._v(" "),t("h2",{attrs:{id:"stream-的终止操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#stream-的终止操作"}},[a._v("#")]),a._v(" Stream 的终止操作")]),a._v(" "),t("p",[a._v("终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如： List、 Integer，甚至是 void 。")]),a._v(" "),t("h3",{attrs:{id:"_1-查找与匹配"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-查找与匹配"}},[a._v("#")]),a._v(" 1.查找与匹配")]),a._v(" "),t("p",[t("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://binghe001.github.io/images/java/java8/2022-03-31-008-005.jpg",loading:"lazy"}})]),a._v(" "),t("p",[t("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://binghe001.github.io/images/java/java8/2022-03-31-008-006.jpg",loading:"lazy"}})]),a._v(" "),t("h3",{attrs:{id:"_2-规约"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-规约"}},[a._v("#")]),a._v(" 2.规约")]),a._v(" "),t("p",[t("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://binghe001.github.io/images/java/java8/2022-03-31-008-007.jpg",loading:"lazy"}})]),a._v(" "),t("h3",{attrs:{id:"_3-收集"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-收集"}},[a._v("#")]),a._v(" 3.收集")]),a._v(" "),t("p",[t("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://binghe001.github.io/images/java/java8/2022-03-31-008-008.jpg",loading:"lazy"}})]),a._v(" "),t("p",[a._v("Collector 接口中方法的实现决定了如何对流执行收集操作(如收集到 List、 Set、 Map)。但是 Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例， 具体方法与实例如下表")]),a._v(" "),t("p",[t("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://binghe001.github.io/images/java/java8/2022-03-31-008-009.jpg",loading:"lazy"}})]),a._v(" "),t("p",[t("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://binghe001.github.io/images/java/java8/2022-03-31-008-010.jpg",loading:"lazy"}})]),a._v(" "),t("h2",{attrs:{id:"并行流与串行流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#并行流与串行流"}},[a._v("#")]),a._v(" 并行流与串行流")]),a._v(" "),t("p",[a._v("并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。")]),a._v(" "),t("p",[a._v("Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。 Stream API 可以声明性地通过 parallel() 与\nsequential() 在并行流与顺序流之间进行切换")]),a._v(" "),t("h2",{attrs:{id:"fork-join-框架"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fork-join-框架"}},[a._v("#")]),a._v(" Fork/Join 框架")]),a._v(" "),t("h3",{attrs:{id:"_1-简单概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-简单概述"}},[a._v("#")]),a._v(" 1.简单概述")]),a._v(" "),t("blockquote",[t("p",[a._v("Fork/Join 框架： 就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总.")])]),a._v(" "),t("p",[t("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://binghe001.github.io/images/java/java8/2022-03-31-008-011.jpg",loading:"lazy"}})]),a._v(" "),t("h3",{attrs:{id:"_2-fork-join-框架与传统线程池的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-fork-join-框架与传统线程池的区别"}},[a._v("#")]),a._v(" 2.Fork/Join 框架与传统线程池的区别")]),a._v(" "),t("p",[a._v("采用 “工作窃取”模式（work-stealing）：\n当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。")]),a._v(" "),t("p",[a._v("相对于一般的线程池实现,fork/join框架的优势体现在对其中包含的任务的处理方式上.在一般的线程池中,如果一个线程正在执行的任务由于某些原因无法继续运行,那么该线程会处于等待状态.而在fork/join框架实现中,如果某个子问题由于等待另外一个子问题的完成而无法继续运行.那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了线程的等待时间,提高了性能。")]),a._v(" "),t("h2",{attrs:{id:"写在最后"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#写在最后"}},[a._v("#")]),a._v(" 写在最后")]),a._v(" "),t("blockquote",[t("p",[a._v("如果你觉得冰河写的还不错，请微信搜索并关注「 "),t("strong",[a._v("冰河技术")]),a._v(" 」微信公众号，跟冰河学习高并发、分布式、微服务、大数据、互联网和云原生技术，「 "),t("strong",[a._v("冰河技术")]),a._v(" 」微信公众号更新了大量技术专题，每一篇技术文章干货满满！不少读者已经通过阅读「 "),t("strong",[a._v("冰河技术")]),a._v(" 」微信公众号文章，吊打面试官，成功跳槽到大厂；也有不少读者实现了技术上的飞跃，成为公司的技术骨干！如果你也想像他们一样提升自己的能力，实现技术能力的飞跃，进大厂，升职加薪，那就关注「 "),t("strong",[a._v("冰河技术")]),a._v(" 」微信公众号吧，每天更新超硬核技术干货，让你对如何提升技术能力不再迷茫！")])]),a._v(" "),t("p",[t("img",{staticClass:"lazy",attrs:{alt:"","data-src":"https://img-blog.csdnimg.cn/20200906013715889.png",loading:"lazy"}})])])}),[],!1,null,null,null);t.default=v.exports}}]);