(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{419:function(t,r,e){"use strict";e.r(r);var a=e(7),s=Object(a.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"《并发设计模式》第47章-串行线程封闭模式-到底什么是串行线程封闭模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#《并发设计模式》第47章-串行线程封闭模式-到底什么是串行线程封闭模式"}},[t._v("#")]),t._v(" 《并发设计模式》第47章-串行线程封闭模式-到底什么是串行线程封闭模式")]),t._v(" "),r("p",[t._v("作者：冰河\n"),r("br"),t._v("星球："),r("a",{attrs:{href:"http://m6z.cn/6aeFbs",target:"_blank",rel:"noopener noreferrer"}},[t._v("http://m6z.cn/6aeFbs"),r("OutboundLink")],1),t._v(" "),r("br"),t._v("博客："),r("a",{attrs:{href:"https://binghe.gitcode.host",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://binghe.gitcode.host"),r("OutboundLink")],1),t._v(" "),r("br"),t._v("文章汇总："),r("a",{attrs:{href:"https://binghe.gitcode.host/md/all/all.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://binghe.gitcode.host/md/all/all.html"),r("OutboundLink")],1),t._v(" "),r("br"),t._v("源码获取地址："),r("a",{attrs:{href:"https://t.zsxq.com/0dhvFs5oR",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://t.zsxq.com/0dhvFs5oR"),r("OutboundLink")],1)]),t._v(" "),r("blockquote",[r("p",[t._v("沉淀，成长，突破，帮助他人，成就自我。")])]),t._v(" "),r("ul",[r("li",[t._v("本章难度：★★☆☆☆")]),t._v(" "),r("li",[t._v("本章重点：了解串行线程封闭模式的核心原理与使用场景，能够初步结合自身项目实际场景思考如何将串行线程封闭模式灵活应用到自身实际项目中。")])]),t._v(" "),r("p",[r("strong",[t._v("大家好，我是冰河~~")])]),t._v(" "),r("p",[t._v("在并发编程中，如果多个线程同时访问同一个共享变量，就会出现线程安全的问题。为了解决线程安全的问题，Java引入了锁技术，包含wait、notify、AQS、Lock、synchronized等多种方案，稍不注意，就可能会出现死锁等问题，并且实现上也比较复杂。那除了加锁能够保证线程安全外，还有其他更优雅的方式吗？")]),t._v(" "),r("h2",{attrs:{id:"一、故事背景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一、故事背景"}},[t._v("#")]),t._v(" 一、故事背景")]),t._v(" "),r("p",[t._v("小菜刚要下班时，被通知要处理一个报表系统导出报表数据错乱的问题。但是奈何自己的编程内功不足，无法很好的分析出问题所在。最终在老王的帮助下，分析出了问题，并初步以单线程线程池的方式解决了问题。不过这还不是解决问题的最佳方案，小菜也得知解决问题的最佳方案就是使用串行线程封闭模式。但是对于小菜来说，这种并发设计模式还是第一次听说，自然是不知道这种设计模式是啥，更别提如何在实际项目中使用了，于是积极上进的小菜为了搞明白到底什么是串行线程封闭模式，自己查阅了很多资料。也带着自己的一些疑问来问老王，老王也耐心的为小菜进行了讲解。")]),t._v(" "),r("h2",{attrs:{id:"二、异步任务"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二、异步任务"}},[t._v("#")]),t._v(" 二、异步任务")]),t._v(" "),r("p",[t._v("在实际场景中，异步执行任务总体上可以分成两类：一类是像生产者消费者模式那样，生产者将任务放入任务队列后即可返回，不必关注后续消费者是如何消费任务的，如图47-1所示。")]),t._v(" "),r("div",{attrs:{align:"center"}},[r("img",{attrs:{src:"https://binghe.gitcode.host/assets/images/core/concurrent/2023-11-03-001.png?raw=true",width:"80%"}}),t._v(" "),r("br")]),t._v(" "),r("p",[t._v("可以看到，生产者只管将生产出的任务放入任务队列即可返回，不必关注后续这些任务是如何被消费的，而消费者会从任务队列中消费任务，不必关注生产者是如何生产任务的，这就达到了异步解耦的目的。")]),t._v(" "),r("p",[t._v("还有一类异步执行任务的场景，那就是像线程池模式那样，以线程池的方式异步执行任务，如图47-2所示。")]),t._v(" "),r("div",{attrs:{align:"center"}},[r("img",{attrs:{src:"https://binghe.gitcode.host/assets/images/core/concurrent/2023-11-03-002.png?raw=true",width:"80%"}}),t._v(" "),r("br")]),t._v(" "),r("p",[r("strong",[t._v("注意：虽然开启单个线程也能异步执行任务，但是不建议在生产环境使用。")])]),t._v(" "),r("p",[t._v("可以看到，多个任务可以在线程池中并行执行，任务队列中每个任务都是独立的，相互之间没有太大的关联性，此时在线程池中并行执行任务对结果数据没有影响。")]),t._v(" "),r("p",[t._v("但是有些场景则不同，有些场景会将任务划分成多个子任务，并且每个子任务都需要按照严格的先后顺序执行，如果线程池中的不同线程分别执行了同一个任务下的不同子任务，就可能对最终的结果数据产生影响，如图47-3所示。")]),t._v(" "),r("h2",{attrs:{id:"查看全文"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#查看全文"}},[t._v("#")]),t._v(" 查看全文")]),t._v(" "),r("p",[t._v("加入"),r("a",{attrs:{href:"http://m6z.cn/6aeFbs",target:"_blank",rel:"noopener noreferrer"}},[t._v("冰河技术"),r("OutboundLink")],1),t._v("知识星球，解锁完整技术文章与完整代码")])])}),[],!1,null,null,null);r.default=s.exports}}]);